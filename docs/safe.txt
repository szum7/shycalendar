abstract class NamelessObject {

    public function ConvertToClass(){
        return null;
    }

}

class EventNO extends NamelessObject {

    private $data;

    public function __construct($data){
        $this->data = $data;
    }

    public function GetId() { return $this->data["id"]; }
    public function GetDate() { return $this->data["date"]; }
    public function GetIntro() { return $this->data["intro"]; }
    public function GetContent() { return $this->data["content"]; }
    public function GetType() { return $this->data["type"]; }

    public function SetId($v) { $this->data["id"] = $v; }
    public function SetDate($v) { $this->data["date"] = $v; }
    public function SetIntro($v) { $this->data["intro"] = $v; }
    public function SetContent($v) { $this->data["content"] = $v; }
    public function SetType($v) { $this->data["type"] = $v; }
}



/**
 * Class casting
 *
 * @param string|object $destination
 * @param object $sourceObject
 * @return object
 */
function Cast($sourceObject, $destination)
{
    if (is_string($destination)) {
        $destination = new $destination();
    }
    $sourceReflection = new ReflectionObject($sourceObject);
    $destinationReflection = new ReflectionObject($destination);
    $sourceProperties = $sourceReflection->getProperties();
    foreach ($sourceProperties as $sourceProperty) {
        $sourceProperty->setAccessible(true);
        $name = $sourceProperty->getName();
        $value = $sourceProperty->getValue($sourceObject);
        if ($destinationReflection->hasProperty($name)) {
            $propDest = $destinationReflection->getProperty($name);
            $propDest->setAccessible(true);
            $propDest->setValue($destination,$value);
        } else {
            $destination->$name = $value;
        }
    }
    return $destination;
}
